<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A push decoder for `ParquetMetaData`."><title>ParquetMetaDataPushDecoder in parquet::file::metadata - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../../../static.files/rustdoc-e56847b5.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="parquet" data-themes="" data-resource-suffix="" data-rustdoc-version="1.91.0-nightly (02c7b1a7a 2025-09-13)" data-channel="nightly" data-search-js="search-cb266a1a.js" data-stringdex-js="stringdex-5af928a3.js" data-settings-js="settings-c38705f0.js" ><script src="../../../static.files/storage-e2aeef58.js"></script><script defer src="sidebar-items.js"></script><script defer src="../../../static.files/main-6dc2a7f3.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-263c88ec.css"></noscript><link rel="icon" href="https://raw.githubusercontent.com/apache/parquet-format/25f05e73d8cd7f5c83532ce51cb4f4de8ba5f2a2/logo/parquet-logos_1.svg"></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">ParquetMetaDataPushDecoder</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../../parquet/index.html"><img src="https://raw.githubusercontent.com/apache/parquet-format/25f05e73d8cd7f5c83532ce51cb4f4de8ba5f2a2/logo/parquet-logos_1.svg" alt="logo"></a><h2><a href="../../../parquet/index.html">parquet</a><span class="version">56.1.0</span></h2></div><div class="sidebar-elems"><section id="rustdoc-toc"><h2 class="location"><a href="#">Parquet<wbr>Meta<wbr>Data<wbr>Push<wbr>Decoder</a></h2><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#example" title="Example">Example</a></li><li><a href="#example-with-prefetching" title="Example with “prefetching”">Example with “prefetching”</a></li><li><a href="#example-using-asyncread" title="Example using `AsyncRead`">Example using <code>AsyncRead</code></a></li></ul><h3><a href="#fields">Fields</a></h3><ul class="block structfield"><li><a href="#structfield.buffers" title="buffers">buffers</a></li><li><a href="#structfield.done" title="done">done</a></li><li><a href="#structfield.metadata_reader" title="metadata_reader">metadata_reader</a></li></ul><h3><a href="#implementations">Methods</a></h3><ul class="block method"><li><a href="#method.push_ranges" title="push_ranges">push_ranges</a></li><li><a href="#method.try_decode" title="try_decode">try_decode</a></li><li><a href="#method.try_new" title="try_new">try_new</a></li><li><a href="#method.with_page_index_policy" title="with_page_index_policy">with_page_index_policy</a></li></ul><h3><a href="#trait-implementations">Trait Implementations</a></h3><ul class="block trait-implementation"><li><a href="#impl-Debug-for-ParquetMetaDataPushDecoder" title="Debug">Debug</a></li></ul><h3><a href="#synthetic-implementations">Auto Trait Implementations</a></h3><ul class="block synthetic-implementation"><li><a href="#impl-RefUnwindSafe-for-ParquetMetaDataPushDecoder" title="!RefUnwindSafe">!RefUnwindSafe</a></li><li><a href="#impl-UnwindSafe-for-ParquetMetaDataPushDecoder" title="!UnwindSafe">!UnwindSafe</a></li><li><a href="#impl-Freeze-for-ParquetMetaDataPushDecoder" title="Freeze">Freeze</a></li><li><a href="#impl-Send-for-ParquetMetaDataPushDecoder" title="Send">Send</a></li><li><a href="#impl-Sync-for-ParquetMetaDataPushDecoder" title="Sync">Sync</a></li><li><a href="#impl-Unpin-for-ParquetMetaDataPushDecoder" title="Unpin">Unpin</a></li></ul><h3><a href="#blanket-implementations">Blanket Implementations</a></h3><ul class="block blanket-implementation"><li><a href="#impl-Any-for-T" title="Any">Any</a></li><li><a href="#impl-Borrow%3CT%3E-for-T" title="Borrow&#60;T&#62;">Borrow&#60;T&#62;</a></li><li><a href="#impl-BorrowMut%3CT%3E-for-T" title="BorrowMut&#60;T&#62;">BorrowMut&#60;T&#62;</a></li><li><a href="#impl-ErasedDestructor-for-T" title="ErasedDestructor">ErasedDestructor</a></li><li><a href="#impl-From%3CT%3E-for-T" title="From&#60;T&#62;">From&#60;T&#62;</a></li><li><a href="#impl-Into%3CU%3E-for-T" title="Into&#60;U&#62;">Into&#60;U&#62;</a></li><li><a href="#impl-IntoEither-for-T" title="IntoEither">IntoEither</a></li><li><a href="#impl-TryFrom%3CU%3E-for-T" title="TryFrom&#60;U&#62;">TryFrom&#60;U&#62;</a></li><li><a href="#impl-TryInto%3CU%3E-for-T" title="TryInto&#60;U&#62;">TryInto&#60;U&#62;</a></li><li><a href="#impl-Ungil-for-T" title="Ungil">Ungil</a></li><li><a href="#impl-VZip%3CV%3E-for-T" title="VZip&#60;V&#62;">VZip&#60;V&#62;</a></li></ul></section><div id="rustdoc-modnav"><h2><a href="index.html">In parquet::<wbr>file::<wbr>metadata</a></h2></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><div class="rustdoc-breadcrumbs"><a href="../../index.html">parquet</a>::<wbr><a href="../index.html">file</a>::<wbr><a href="index.html">metadata</a></div><h1>Struct <span class="struct">Parquet<wbr>Meta<wbr>Data<wbr>Push<wbr>Decoder</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../../../src/parquet/file/metadata/push_decoder.rs.html#194-198">Source</a> </span></div><pre class="rust item-decl"><code>pub struct ParquetMetaDataPushDecoder {
    done: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,
    metadata_reader: <a class="struct" href="struct.ParquetMetaDataReader.html" title="struct parquet::file::metadata::ParquetMetaDataReader">ParquetMetaDataReader</a>,
    buffers: PushBuffers,
}</code></pre><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A push decoder for <a href="struct.ParquetMetaData.html" title="struct parquet::file::metadata::ParquetMetaData"><code>ParquetMetaData</code></a>.</p>
<p>This structure implements a push API based version of the <a href="struct.ParquetMetaDataReader.html" title="struct parquet::file::metadata::ParquetMetaDataReader"><code>ParquetMetaDataReader</code></a>, which
decouples the IO from the metadata decoding logic.</p>
<p>You can use this decoder to customize your IO operations, as shown in the
examples below for minimizing bytes read, prefetching data, or
using async IO.</p>
<h2 id="example"><a class="doc-anchor" href="#example">§</a>Example</h2>
<p>The most basic usage is to feed the decoder with the necessary byte ranges
as requested as shown below.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// The `ParquetMetaDataPushDecoder` needs to know the file length.
</span><span class="kw">let </span><span class="kw-2">mut </span>decoder = ParquetMetaDataPushDecoder::try_new(file_len).unwrap();
<span class="comment">// try to decode the metadata. If more data is needed, the decoder will tell you what ranges
</span><span class="kw">loop </span>{
    <span class="kw">match </span>decoder.try_decode() {
       <span class="prelude-val">Ok</span>(DecodeResult::Data(metadata)) =&gt; { <span class="kw">return </span><span class="prelude-val">Ok</span>(metadata); } <span class="comment">// decode successful
       </span><span class="prelude-val">Ok</span>(DecodeResult::NeedsData(ranges)) =&gt; {
          <span class="comment">// The decoder needs more data
          //
          // In this example, we call a function that returns the bytes for each given range.
          // In a real application, you would likely read the data from a file or network.
          </span><span class="kw">let </span>data = ranges.iter().map(|range| get_range(range)).collect();
          <span class="comment">// Push the data into the decoder and try to decode again on the next iteration.
          </span>decoder.push_ranges(ranges, data).unwrap();
       }
       <span class="prelude-val">Ok</span>(DecodeResult::Finished) =&gt; { <span class="macro">unreachable!</span>(<span class="string">"returned metadata in previous match arm"</span>) }
       <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(e),
    }
}</code></pre></div><h2 id="example-with-prefetching"><a class="doc-anchor" href="#example-with-prefetching">§</a>Example with “prefetching”</h2>
<p>By default, the <a href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder"><code>ParquetMetaDataPushDecoder</code></a> will request only the exact byte
ranges it needs. This minimizes the number of bytes read, however it
requires at least two IO operations to read the metadata - one to read the
footer and then one to read the metadata.</p>
<p>If the file has a “Page Index” (see <a href="struct.ParquetMetaDataPushDecoder.html#method.with_page_index_policy" title="method parquet::file::metadata::ParquetMetaDataPushDecoder::with_page_index_policy">Self::with_page_index_policy</a>), three
IO operations are required to read the metadata, as the page index is
not part of the normal metadata footer.</p>
<p>To reduce the number of IO operations in systems with high per operation
overhead (e.g. cloud storage), you can “prefetch” the data and then push
the data into the decoder before calling <a href="struct.ParquetMetaDataPushDecoder.html#method.try_decode" title="method parquet::file::metadata::ParquetMetaDataPushDecoder::try_decode"><code>Self::try_decode</code></a>. If you do
not push enough bytes, the decoder will return the ranges that are still
needed.</p>
<p>This approach can also be used when you have the entire file already in memory
for other reasons.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span>file_len = file_bytes.len() <span class="kw">as </span>u64;
<span class="comment">// For this example, we "prefetch" all the bytes which we have in memory,
// but in a real application, you would likely read a chunk from the end
// for example 1MB.
</span><span class="kw">let </span>prefetched_bytes = file_bytes.clone();
<span class="kw">let </span><span class="kw-2">mut </span>decoder = ParquetMetaDataPushDecoder::try_new(file_len).unwrap();
<span class="comment">// push the prefetched bytes into the decoder
</span>decoder.push_ranges(<span class="macro">vec!</span>[<span class="number">0</span>..file_len], <span class="macro">vec!</span>[prefetched_bytes]).unwrap();
<span class="comment">// The decoder will now be able to decode the metadata. Note in a real application,
// unless you can guarantee that the pushed data is enough to decode the metadata,
// you still need to call `try_decode` in a loop until it returns `DecodeResult::Data`
// as shown in  the previous example
 </span><span class="kw">match </span>decoder.try_decode() {
     <span class="prelude-val">Ok</span>(DecodeResult::Data(metadata)) =&gt; { <span class="kw">return </span><span class="prelude-val">Ok</span>(metadata); } <span class="comment">// decode successful
     </span>other =&gt; { <span class="macro">panic!</span>(<span class="string">"expected DecodeResult::Data, got: {other:?}"</span>) }
 }</code></pre></div><h2 id="example-using-asyncread"><a class="doc-anchor" href="#example-using-asyncread">§</a>Example using <a href="tokio::io::AsyncRead"><code>AsyncRead</code></a></h2>
<p><a href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder"><code>ParquetMetaDataPushDecoder</code></a> is designed to work with any data source that can
provide byte ranges, including async IO sources. However, it does not
implement async IO itself. To use async IO, you simply write an async
wrapper around it that reads the required byte ranges and pushes them into the
decoder.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>tokio::io::{AsyncRead, AsyncReadExt, AsyncSeek, AsyncSeekExt};
<span class="comment">// This function decodes Parquet Metadata from anything that implements
// [`AsyncRead`] and [`AsyncSeek`] such as a tokio::fs::File
</span><span class="kw">async fn </span>decode_metadata(
  file_len: u64,
  <span class="kw-2">mut </span>async_source: <span class="kw">impl </span>AsyncRead + AsyncSeek + Unpin
) -&gt; <span class="prelude-ty">Result</span>&lt;ParquetMetaData, ParquetError&gt; {
  <span class="comment">// We need a ParquetMetaDataPushDecoder to decode the metadata.
  </span><span class="kw">let </span><span class="kw-2">mut </span>decoder = ParquetMetaDataPushDecoder::try_new(file_len).unwrap();
  <span class="kw">loop </span>{
    <span class="kw">match </span>decoder.try_decode() {
       <span class="prelude-val">Ok</span>(DecodeResult::Data(metadata)) =&gt; { <span class="kw">return </span><span class="prelude-val">Ok</span>(metadata); } <span class="comment">// decode successful
       </span><span class="prelude-val">Ok</span>(DecodeResult::NeedsData(ranges)) =&gt; {
          <span class="comment">// The decoder needs more data
          //
          // In this example we use the AsyncRead and AsyncSeek traits to read the
          // required ranges from the async source.
          </span><span class="kw">let </span><span class="kw-2">mut </span>data = Vec::with_capacity(ranges.len());
          <span class="kw">for </span>range <span class="kw">in </span><span class="kw-2">&amp;</span>ranges {
            <span class="kw">let </span><span class="kw-2">mut </span>buffer = <span class="macro">vec!</span>[<span class="number">0</span>; (range.end - range.start) <span class="kw">as </span>usize];
            async_source.seek(std::io::SeekFrom::Start(range.start)).<span class="kw">await</span><span class="question-mark">?</span>;
            async_source.read_exact(<span class="kw-2">&amp;mut </span>buffer).<span class="kw">await</span><span class="question-mark">?</span>;
            data.push(Bytes::from(buffer));
          }
          <span class="comment">// Push the data into the decoder and try to decode again on the next iteration.
          </span>decoder.push_ranges(ranges, data).unwrap();
       }
       <span class="prelude-val">Ok</span>(DecodeResult::Finished) =&gt; { <span class="macro">unreachable!</span>(<span class="string">"returned metadata in previous match arm"</span>) }
       <span class="prelude-val">Err</span>(e) =&gt; <span class="kw">return </span><span class="prelude-val">Err</span>(e),
    }
  }
}</code></pre></div></div></details><h2 id="fields" class="fields section-header">Fields<a href="#fields" class="anchor">§</a></h2><span id="structfield.done" class="structfield section-header"><a href="#structfield.done" class="anchor field">§</a><code>done: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code></span><span id="structfield.metadata_reader" class="structfield section-header"><a href="#structfield.metadata_reader" class="anchor field">§</a><code>metadata_reader: <a class="struct" href="struct.ParquetMetaDataReader.html" title="struct parquet::file::metadata::ParquetMetaDataReader">ParquetMetaDataReader</a></code></span><span id="structfield.buffers" class="structfield section-header"><a href="#structfield.buffers" class="anchor field">§</a><code>buffers: PushBuffers</code></span><h2 id="implementations" class="section-header">Implementations<a href="#implementations" class="anchor">§</a></h2><div id="implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-ParquetMetaDataPushDecoder" class="impl"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#200-326">Source</a><a href="#impl-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.try_new" class="method"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#207-222">Source</a><h4 class="code-header">pub fn <a href="#method.try_new" class="fn">try_new</a>(file_len: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;Self, <a class="enum" href="../../errors/enum.ParquetError.html" title="enum parquet::errors::ParquetError">ParquetError</a>&gt;</h4></section></summary><div class="docblock"><p>Create a new <code>ParquetMetaDataPushDecoder</code> with the given file length.</p>
<p>By default, this will read page indexes and column indexes. See
<a href="struct.ParquetMetaDataPushDecoder.html#method.with_page_index_policy" title="method parquet::file::metadata::ParquetMetaDataPushDecoder::with_page_index_policy"><code>ParquetMetaDataPushDecoder::with_page_index_policy</code></a> for more detail.</p>
<p>See examples on <a href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder"><code>ParquetMetaDataPushDecoder</code></a>.</p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.with_page_index_policy" class="method"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#234-239">Source</a><h4 class="code-header">pub fn <a href="#method.with_page_index_policy" class="fn">with_page_index_policy</a>(self, page_index_policy: <a class="enum" href="enum.PageIndexPolicy.html" title="enum parquet::file::metadata::PageIndexPolicy">PageIndexPolicy</a>) -&gt; Self</h4></section></summary><div class="docblock"><p>Enable or disable reading the page index structures described in
“<a href="https://github.com/apache/parquet-format/blob/master/PageIndex.md">Parquet page index</a> Layout to Support Page Skipping”.</p>
<p>Defaults to <a href="enum.PageIndexPolicy.html#variant.Optional" title="variant parquet::file::metadata::PageIndexPolicy::Optional"><code>PageIndexPolicy::Optional</code></a></p>
<p>This requires</p>
<ol>
<li>The Parquet file to have been written with page indexes</li>
<li>Additional data to be pushed into the decoder (as the page indexes are not part of the thrift footer)</li>
</ol>
</div></details><details class="toggle method-toggle" open><summary><section id="method.push_ranges" class="method"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#260-273">Source</a><h4 class="code-header">pub fn <a href="#method.push_ranges" class="fn">push_ranges</a>(
    &amp;mut self,
    ranges: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;<a class="struct" href="https://doc.rust-lang.org/nightly/core/ops/range/struct.Range.html" title="struct core::ops::range::Range">Range</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.u64.html">u64</a>&gt;&gt;,
    buffers: <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/vec/struct.Vec.html" title="struct alloc::vec::Vec">Vec</a>&lt;Bytes&gt;,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.unit.html">()</a>, <a class="struct" href="https://doc.rust-lang.org/nightly/alloc/string/struct.String.html" title="struct alloc::string::String">String</a>&gt;</h4></section></summary><div class="docblock"><p>Push the data into the decoder’s buffer.</p>
<p>The decoder does not immediately attempt to decode the metadata
after pushing data. Instead, it accumulates the pushed data until you
call <a href="struct.ParquetMetaDataPushDecoder.html#method.try_decode" title="method parquet::file::metadata::ParquetMetaDataPushDecoder::try_decode"><code>Self::try_decode</code></a>.</p>
<h5 id="determining-required-data"><a class="doc-anchor" href="#determining-required-data">§</a>Determining required data:</h5>
<p>To determine what ranges are required to decode the metadata, you can
either:</p>
<ol>
<li>
<p>Call <a href="struct.ParquetMetaDataPushDecoder.html#method.try_decode" title="method parquet::file::metadata::ParquetMetaDataPushDecoder::try_decode"><code>Self::try_decode</code></a> first to get the exact ranges required (see
example on <a href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder"><code>Self</code></a>)</p>
</li>
<li>
<p>Speculatively push any data that you have available, which may
include more than the footer data or requested bytes.</p>
</li>
</ol>
<p>Speculatively pushing data can be used when  “prefetching” data. See
example on <a href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder"><code>Self</code></a></p>
</div></details><details class="toggle method-toggle" open><summary><section id="method.try_decode" class="method"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#277-325">Source</a><h4 class="code-header">pub fn <a href="#method.try_decode" class="fn">try_decode</a>(
    &amp;mut self,
) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;<a class="enum" href="../../enum.DecodeResult.html" title="enum parquet::DecodeResult">DecodeResult</a>&lt;<a class="struct" href="struct.ParquetMetaData.html" title="struct parquet::file::metadata::ParquetMetaData">ParquetMetaData</a>&gt;, <a class="enum" href="../../errors/enum.ParquetError.html" title="enum parquet::errors::ParquetError">ParquetError</a>&gt;</h4></section></summary><div class="docblock"><p>Try to decode the metadata from the pushed data, returning the
decoded metadata or an error if not enough data is available.</p>
</div></details></div></details></div><h2 id="trait-implementations" class="section-header">Trait Implementations<a href="#trait-implementations" class="anchor">§</a></h2><div id="trait-implementations-list"><details class="toggle implementors-toggle" open><summary><section id="impl-Debug-for-ParquetMetaDataPushDecoder" class="impl"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#193">Source</a><a href="#impl-Debug-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html" title="trait core::fmt::Debug">Debug</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.fmt" class="method trait-impl"><a class="src rightside" href="../../../src/parquet/file/metadata/push_decoder.rs.html#193">Source</a><a href="#method.fmt" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt" class="fn">fmt</a>(&amp;self, f: &amp;mut <a class="struct" href="https://doc.rust-lang.org/nightly/core/fmt/struct.Formatter.html" title="struct core::fmt::Formatter">Formatter</a>&lt;'_&gt;) -&gt; <a class="type" href="https://doc.rust-lang.org/nightly/core/fmt/type.Result.html" title="type core::fmt::Result">Result</a></h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href="https://doc.rust-lang.org/nightly/core/fmt/trait.Debug.html#tymethod.fmt">Read more</a></div></details></div></details></div><h2 id="synthetic-implementations" class="section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor">§</a></h2><div id="synthetic-implementations-list"><section id="impl-Freeze-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-Freeze-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Freeze.html" title="trait core::marker::Freeze">Freeze</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section><section id="impl-RefUnwindSafe-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-RefUnwindSafe-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.RefUnwindSafe.html" title="trait core::panic::unwind_safe::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section><section id="impl-Send-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-Send-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section><section id="impl-Sync-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-Sync-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section><section id="impl-Unpin-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-Unpin-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section><section id="impl-UnwindSafe-for-ParquetMetaDataPushDecoder" class="impl"><a href="#impl-UnwindSafe-for-ParquetMetaDataPushDecoder" class="anchor">§</a><h3 class="code-header">impl !<a class="trait" href="https://doc.rust-lang.org/nightly/core/panic/unwind_safe/trait.UnwindSafe.html" title="trait core::panic::unwind_safe::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.ParquetMetaDataPushDecoder.html" title="struct parquet::file::metadata::ParquetMetaDataPushDecoder">ParquetMetaDataPushDecoder</a></h3></section></div><h2 id="blanket-implementations" class="section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor">§</a></h2><div id="blanket-implementations-list"><details class="toggle implementors-toggle"><summary><section id="impl-Any-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#138">Source</a><a href="#impl-Any-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T<div class="where">where
    T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.type_id" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#139">Source</a><a href="#method.type_id" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fn">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></h4></section></summary><div class='docblock'>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Borrow%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#212">Source</a><a href="#impl-Borrow%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#214">Source</a><a href="#method.borrow" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fn">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;T</a></h4></section></summary><div class='docblock'>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-BorrowMut%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#221">Source</a><a href="#impl-BorrowMut%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T<div class="where">where
    T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.borrow_mut" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#222">Source</a><a href="#method.borrow_mut" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fn">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut T</a></h4></section></summary><div class='docblock'>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-From%3CT%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#785">Source</a><a href="#impl-From%3CT%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#788">Source</a><a href="#method.from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fn">from</a>(t: T) -&gt; T</h4></section></summary><div class="docblock"><p>Returns the argument unchanged.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-Into%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#767-769">Source</a><a href="#impl-Into%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#777">Source</a><a href="#method.into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fn">into</a>(self) -&gt; U</h4></section></summary><div class="docblock"><p>Calls <code>U::from(self)</code>.</p>
<p>That is, this conversion is whatever the implementation of
<code><a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for U</code> chooses to do.</p>
</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-IntoEither-for-T" class="impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#64">Source</a><a href="#impl-IntoEither-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; <a class="trait" href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html" title="trait either::into_either::IntoEither">IntoEither</a> for T</h3></section></summary><div class="impl-items"><details class="toggle method-toggle" open><summary><section id="method.into_either" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#29">Source</a><a href="#method.into_either" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either" class="fn">into_either</a>(self, into_left: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;</h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left</code> is <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either">Read more</a></div></details><details class="toggle method-toggle" open><summary><section id="method.into_either_with" class="method trait-impl"><a class="src rightside" href="https://docs.rs/either/1/src/either/into_either.rs.html#55-57">Source</a><a href="#method.into_either_with" class="anchor">§</a><h4 class="code-header">fn <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with" class="fn">into_either_with</a>&lt;F&gt;(self, into_left: F) -&gt; <a class="enum" href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either">Either</a>&lt;Self, Self&gt;<div class="where">where
    F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(&amp;Self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a>,</div></h4></section></summary><div class='docblock'>Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Left" title="variant either::Either::Left"><code>Left</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
if <code>into_left(&amp;self)</code> returns <code>true</code>.
Converts <code>self</code> into a <a href="https://docs.rs/either/1/either/enum.Either.html#variant.Right" title="variant either::Either::Right"><code>Right</code></a> variant of <a href="https://docs.rs/either/1/either/enum.Either.html" title="enum either::Either"><code>Either&lt;Self, Self&gt;</code></a>
otherwise. <a href="https://docs.rs/either/1/either/into_either/trait.IntoEither.html#method.into_either_with">Read more</a></div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryFrom%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#827-829">Source</a><a href="#impl-TryFrom%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error-1" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#831">Source</a><a href="#associatedtype.Error-1" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="associatedtype">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_from" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#834">Source</a><a href="#method.try_from" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fn">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-TryInto%3CU%3E-for-T" class="impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#811-813">Source</a><a href="#impl-TryInto%3CU%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T<div class="where">where
    U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><details class="toggle" open><summary><section id="associatedtype.Error" class="associatedtype trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#815">Source</a><a href="#associatedtype.Error" class="anchor">§</a><h4 class="code-header">type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="associatedtype">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></h4></section></summary><div class='docblock'>The type returned in the event of a conversion error.</div></details><details class="toggle method-toggle" open><summary><section id="method.try_into" class="method trait-impl"><a class="src rightside" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#818">Source</a><a href="#method.try_into" class="anchor">§</a><h4 class="code-header">fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fn">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="associatedtype" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</h4></section></summary><div class='docblock'>Performs the conversion.</div></details></div></details><details class="toggle implementors-toggle"><summary><section id="impl-VZip%3CV%3E-for-T" class="impl"><a href="#impl-VZip%3CV%3E-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;V, T&gt; VZip&lt;V&gt; for T<div class="where">where
    V: MultiLane&lt;T&gt;,</div></h3></section></summary><div class="impl-items"><section id="method.vzip" class="method trait-impl"><a href="#method.vzip" class="anchor">§</a><h4 class="code-header">fn <a class="fn">vzip</a>(self) -&gt; V</h4></section></div></details><section id="impl-ErasedDestructor-for-T" class="impl"><a href="#impl-ErasedDestructor-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; ErasedDestructor for T<div class="where">where
    T: 'static,</div></h3></section><section id="impl-Ungil-for-T" class="impl"><a href="#impl-Ungil-for-T" class="anchor">§</a><h3 class="code-header">impl&lt;T&gt; Ungil for T<div class="where">where
    T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a>,</div></h3></section></div></section></div></main></body></html>